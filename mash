#!/usr/bin/env bash

debug_chan=$(mktemp -u --suffix=.debug_chan)
debug_tail_pid=

function std.debug.log() {
	local file="${BASH_SOURCE[1]}:${BASH_LINENO[0]} in ${FUNCNAME[1]}"
	echo "$file:" "$@" >> /dev/stderr
}
function std.error.log() {
	echo "[error]" "$@" >> /dev/stderr
	echo "[error]" "Trace:" >> /dev/stderr
	for i in $(seq 1 $(( ${#FUNCNAME[@]} - 1 ))); do
		echo "    ${BASH_SOURCE[$i]}:${BASH_LINENO[$i - 1]} in ${FUNCNAME[$i]}" >> /dev/stderr
	done
}
function std.assert() {
	local actual="$1"
	local expected="$2"
	if [ "$actual" != "$expected" ]; then
		std.error.log "Assertion failed:"
		echo "Actual:"
		echo "$actual" | nl
		echo "Expected:"
		echo "$expected" | nl
		exit 1
	fi
}
function std.quote() {
	local str="$1"
	declare -p str | cut -d'=' -f2-
}
std.assert "$(std.quote 'a b "c d" e')" '"a b \"c d\" e"'
std.assert "$(std.quote "a b 'c d' e")" '"a b '"'"'c d'"'"' e"'


function throttle() {
	stdbuf -oL nl | while read -r idx line; do
		echo "($idx) Throttling" >> $debug_chan
		echo "$line"
		sleep $1
	done
}
function look() {
	t cat
}
function t() {
	cmd="$@"
	loc="${BASH_SOURCE[1]}:${BASH_LINENO[0]}"
	"$@" | while read -r line; do
		echo "+ $loc: t $cmd" >> $debug_chan
		echo -e "\t${indent}$line" >> $debug_chan
		echo "$line"
	done
}
function start_monitor() {
	mkfifo $debug_chan
	tail -f $debug_chan &
	debug_tail_pid=$!
}
function stop_monitor() {
	kill $debug_tail_pid
	wait
}
# Experimental
function std.array() {
	local cmd=""
	local name=""
	local value=""
	local sep=","
	local index=""

	cmd="$1"
	shift
	args=("$@")

	for arg in "${args[@]}"; do
		case "$arg" in
			--name=*) name="${arg#*=}" ;;
			--value=*) value="${arg#*=}" ;;
			--sep=*) sep="${arg#*=}" ;;
			--index=*) index="${arg#*=}" ;;
			--index2=*) index2="${arg#*=}" ;;
		esac
	done

	case "$cmd" in
		"new") echo "$value" | tr "$sep" "\n" > "/dev/shm/array-$name" ;;
		"get")
			if [ -z "$index" ]; then
				cat "/dev/shm/array-$name"
			else
				cat "/dev/shm/array-$name" | sed -n "${index}p"
			fi
			;;
		"del")
			if [ -z "$index" ]; then
				rm "/dev/shm/array-$name"
			else
				cat "/dev/shm/array-$name" > /tmp/tmp
				cat /tmp/tmp | sed -e "${index}d" > "/dev/shm/array-$name"
			fi
			;;
		"swap")
			# TODO
			;;
		*) echo "Unknown command: $cmd" ;;
	esac
}
std.assert "$(std.array new --name=sequence --value=a,b,c,d,e,f --sep=,)" ""
std.assert "$(std.array get --name=sequence)" "$(echo -e "a\nb\nc\nd\ne\nf\n")"
std.assert "$(std.array get --name=sequence --index=2)" "b"
std.assert "$(std.array del --name=sequence --index=2)" ""
std.assert "$(std.array get --name=sequence)" "$(echo -e "a\nc\nd\ne\nf\n")"

function std.split() {
	# Split into lines
	local sep="${1}"
	if [ -z "$sep" ]; then
		# Split into characters
		# This is slightly faster than `grep -o .`
		fold -w1
	else
		sed "s/$sep/\n/g"
	fi
}
function std.join() {
	local sep="${1:-,}"
	paste -sd "$sep"
}
function std.replace() {
	local regx="$1"
	local repl="$2"
	sed "s/$regx/$repl/"
}
function std.replace_all() {
	local regx="$1"
	local repl="$2"
	sed "s/$regx/$repl/g"
}
function std.read() {
	local args=()
	local sep=""

	for arg in "$@"; do
		case "$arg" in
			--sep=*) sep="${arg#*=}" ;;
			*) args+=("$arg") ;;
		esac
	done

	if [ -n "$sep" ]; then
		IFS="$sep" read -r "${args[@]}"
	else
		read -r "${args[@]}"
	fi
}
function std.count_lines() {
	wc -l
}
function std.eval_math() {
	# if no argument is passed, start bc
	if [ $# -eq 0 ]; then
		bc
	else
		echo "$1" | bc
	fi
}
function std.filter_line_number() {
	local sed_args=()
	for line in "$@"; do
		sed_args+=("${line}p")
	done

	sed -n "${sed_args[@]}"
}
function std.filter_regex() {
	local regx="$1"
	grep -P "$regx" || true
}
function std.filter_literal() {
	local regx="$1"
	grep --fixed-strings "$regx" || true
}
function std.find() {
	local regx="$1"
	local path="$2"
	grep -P "$regx" -R "$path" || true
}
function std.find_whole() {
	local regx="$1"
	local path="$2"
	grep -w -P "$regx" -R "$path" || true
}
function std.any() {
	# exit immediately with 0 if anything in stdin
	grep -q .
}
function std.sort_numeric() {
	sort -n
}
function std.reverse() {
	tac
}
function std.create() {
	touch "$@"
}
function std.both() {
	# Send stderr to stdout
	"$@" 2>&1
}
function std.redirect() {
	which="$1"
	where="$2"
	shift 2
	case "$which" in
		stdout) "$@" > "$where" ;;
		stderr) "$@" 2> "$where" ;;
		*) echo "Unknown redirection: $which" ;;
	esac
}
function std.ignore_stderr() {
	# Send stderr to /dev/null
	std.redirect 2 /dev/nullk "$@"
}
function std.range() {
	beg="${1:-1}"
	end="${2:-}"
	if [ -z "$end" ]; then
		yes x | nl -v $beg | col1
	else
		seq "$beg" "$end"
	fi
}

{
	function error_handler() {
	    echo "Error in file ${BASH_SOURCE[1]}:${BASH_LINENO[0]} in ${BASH_COMMAND}"
	}
	set -euo pipefail
	trap error_handler ERR
}
{
	trap stop_monitor EXIT
}

function interpret() {
	local expr_str=
	local source_file=
	local verbose=false

	while getopts "c:f:v" opt; do
	    case $opt in
		v) verbose=true ;;
		c) expr_str="$OPTARG" ;;
		f) source_file="$OPTARG" ;;
		*) echo "Invalid option"; exit 1 ;;
	    esac
	done

	# Display remaining arguments
	shift $((OPTIND - 1))
	# "Remaining arguments: $@"

	if [ -n "$source_file" ]; then
		std.verbose $verbose std.source "$source_file"
	fi
	if [ -n "$expr_str" ]; then
		std.verbose $verbose std.eval "$expr_str"
	fi
}

function std.cond() {
	local cond=$1
	if $cond; then
		shift
		"$@"
	fi
}
function std.verbose() {
	local verbose=$1
	shift
	if $verbose; then
		set -x
		"$@"
		{ set +x; } 2> /dev/null
	else
		"$@"
	fi
}

function std.make() {
	local cwd="$(pwd)"
	for target in "$@"; do
		cd "$cwd"
		if [ -e "$target" ]; then
			std.debug.log "Target $(std.quote "$target") OK"
		else
			std.debug.log "Making target $(std.quote "$target")..."
			# We expect a function with the same name as the target
			std.eval "$target" # || echo "Failed to make $target $?"
		fi
	done
}
function std.eval() {
	eval "$@" || {
		local exit_code=$?
		std.error.log "Failed to eval $(std.quote "$*"): exit code $exit_code"
		exit $exit_code
	}
}
function std.source() {
	source "$@" || {
		local exit_code=$?
		std.error.log "Failed to source $(std.quote "$*"): exit code $exit_code"
		exit $exit_code
	}
}

function std.parse_args() {
	std.debug.log "TODO: implement std.parse_args"
}


function run_subcommand() {
	# TODO: apparently this is needed when I run `bash -c 'source mash; source script'`
	# if [ $# -eq 0 ]; then
	# 	return
	# fi
	local command="$1"
	shift

	for registered_command in "${mash_user_commands[@]}"; do
		if [ "$command" == "$registered_command" ]; then
			"$command" "$@"
			exit
		fi
	done
}


start_monitor
interpret "$@"
run_subcommand "$@"
